|||
|:---|:---|
| Title | SQLアンチパターン |
| ISBN | 978-4873115894 |
| Errata | https://www.oreilly.co.jp/books/9784873115894/ |

----

落とし穴を避けるための復習。何年か前に読んだはずですが、だいぶ忘れてきているので。

# 1: ジェイウォーク (信号無視)

## 何をしたか
あるレコードに複数のデータ(関連するレコードのIDなど)を格納したい → カンマ区切りリスト等にして入れてしまう

## 問題
* 検索が容易ではなくなる
* 適切なカラム制約が設定できなくなる
  * たとえば関連であれば、本来なら外部キーが設定できる可能性がある
  * 他にも、このカラムにVARCHARを使うならリストが収まるサイズを予約するといった残念なことをする必要が出てくる
* 「問題の無い区切り文字を決める」ような作業が発生する
  * IDリストならまだしも、ユーザー入力が入るような場所でやったら無理がある

## 解決策
* 一対多の関連なら、テーブルを作って正規化する
* 多対多の関連なら、その関連を表現するための交差テーブルを作る

## 例外
* パフォーマンスのための意図的な非正規化
* 特に検索などの必要がなく、むしろカンマ区切りのリストをそのままの形で保存する必要がある場合

## 感想
RDBで正規化を怠る時は、その場しのぎの意図が見え隠れしていることがしばしばあるように思う。  
アプリケーションのレイヤーのエンジニアはテーブル作るのを面倒に思いがち。

データを保存する最終防衛線がいい加減になってしまうのは、アプリケーションの首を絞めるので避けないといけないですね。

# 2: ナイーブツリー (素朴な木)

## 何をしたか
階層構造を表現したい → 親ノードのIDを持つようにした

## 問題
* クエリに単純に子孫を含めることができない
  * 直接の親、または子くらいなら1つのJOINで可能だが、深くなるほどその数が増える
* キーの整合性を保ちながらサブツリーを削除するためには、全ての子孫を洗い出して最も下から操作する必要がある

## 解決策
* 経路列挙
  * `1/2/3` のようにフルパスを持つイメージ。
  * 検索しやすくなるが、参照整合性は担保できない。
* 入れ子集合
  * 親の情報ではなく、子孫に関する情報(左端, 右端値)を持つ。木構造を集合として捉えている。あるノードAの左端値は全ての子孫が持つ値より小さく、右端値は全ての子孫が持つ値より大きい。
  * サブツリーの検索やノードの削除には強いが、親の取得やノードの挿入・移動には弱い。
  * ノード間の参照整合性は担保できない。
* 閉包テーブル
  * 全ての親子関係を保持するテーブルを追加する。
  * 深さは別途持っておかないと毎回計算するはめに遭う。
  * レコードが極端に増える可能性を持っている。

## 例外
* WITH句をサポートしているRDBMSなら、クエリに子孫を含めたい際の問題は無くなる
  * 本ではSQLServer 2005、Oracle 11g、DB2、MySQL 8.0、PostgreSQL 8.4、SQLite 3.8.3、Firebird 2.1でサポートされていると書かれている

## 感想
これはやったことがあるはずだが、どこでやったのか思い出せない……。  
経路列挙に近いものとして、固定で深さ1のID、2のID、……という列を持たせるのはやったことがある。深さに制限が発生するが、本書記載のようにVARCHARひとつに文字列結合して入れるよりは多少マシかも。ただ、いずれにせよ参照整合性は保てない。

ただナイーブツリー自体、削除のような操作には難があるもののMySQL 8系がより浸透すればあまり問題にはならなさそう。  
いつ浸透していくのかという話はありますが……。

# 3: IDリクワイアド

## 何をしたか
主キーを設定したい → とりあえず「id」列を作成する

## 問題
* 他に自然キーを持つテーブルの場合、冗長な存在となる
* 組み合わせで一意性が必要な場合、そもそもその組み合わせで主キーにすればいい点を見逃すことがある
  * employee_id + もう1つ何かのID のようなケース
* 何も考えずに「id」なんて名前を使うと、列の意味が取りにくくなる

## 解決策
「思考停止をやめる」に尽きている。

* 主キーには分かりやすい名前を付ける
* ORMの規約に縛られない
  * この2つはほぼ同じ話
* 自然キー、複合キーを活用する

## 例外
* ORMの規約に従う場合
  * ただし、idという名前に縛られる必要は無いはずだし、オートインクリメントが必須とも限らないし、テーブルによっては不要である点を忘れてはいけない
* 自然キーが長すぎる場合

## 感想
筆者はあくまでRDBのテーブル設計の観点から話しているので、フレームワークの規約に対する当たりが強い。  
実際、アプリケーションから見れば真っ当でも、DDLだけで語ると不適切なものになることは度々ありますが。

個人的には自然キーで設計するのを好んでいるので、この章の主張についてはとても頷ける。

大抵のORMは複合主キーと相性が悪いのが、話を上手く行かなくさせているように思う。疑似キー(代理キー)のシーケンスだけを信じろみたいな前提で作り込むのやめてほしい……。

# 4: キーレスエントリ (外部キー嫌い)

## 何をしたか

データベース設計をシンプルにしたい → 外部キーを使わない

## 問題
* 参照整合性をRDB側で保証できないということは、それを他の手段で保証する責任が発生する
  * 本当に完璧に保証するコードを書けますか？ということらしい
* ということで、いつでも簡単に参照整合性が失われる可能性がある
  * ふつう、参照整合性が保たれていることを前提にコーディングしているはずであり、おかしなことになる……

## 解決策
「外部キーを使う」
* RDBのレイヤーで制約を強制することによって、アプリケーションの負担を減らす
* あらゆる不整合はエラーとなって回避される
* カスケード設定によって自動削除や、逆に関連付けが生きている間の削除を禁止することもできる

## 例外
* 外部キーを使用できないRDBMSを使っている場合
* 極端に柔軟なテーブル設計の場合
  * ただし、そういった設計は他のアンチパターンに嵌っている恐れがある

## 感想
可能な限り使ったほうがいいのはとても分かる。かつての現場では全く使われていませんでしたが……。  
今のチームにおいても、理由が無ければ基本的に外部キーを設定するような方針になっている。

カスケード削除は安易に使っていると、データが大規模になった時の爆弾になりそうだから少し不安。これはRailsの `dependent: :destroy` にも言える。

# 5: EAV (Entity Attirbute Value)

## 何をしたか
可変な属性をサポートしたい → 汎用な属性テーブル(属性名とその値を持ったテーブル)を作る

## 問題
* 1つの属性を取得するだけのことにWHEREが必要になる
* 必須属性が設定できない
* データ型を設定できない
  * あらゆる型の列を持つ方法もあるが、どう考えてもごり押ししているだけ
* 通常の行のようにひとつの行として取得したい場合、何重にもJOINする必要がでてくる

## 解決策
「モデリングを放棄しない」

継承のようなモデルで、サブタイプには追加の属性があるようなパターンであれば…
* Single Table Inheritance
  * 全て同じテーブルに入れる。サブタイプを認識するためのtype列を追加で持つ。
  * サブタイプの固有属性が少なく、Active Recordパターンを使うような場合に有効。
* Concrete Table Inheritance
  * サブタイプごとにテーブルを作る。共有する属性も、それぞれで持つ。
  * 全てのサブタイプを横断した検索をしない場合は有効。
* Class Table Inheritance
  * 共有する属性のテーブルと、サブタイプごとに固有属性を持つテーブルとで分ける。
  * 全てのサブタイプを横断して、共通属性にアクセスする場合に有効。
* 半構造化データ
  * TEXTカラムを作って、JSONなどにして入れる
  * 検索は面倒になる
  * (これ本当に解決しているのか…?)

## 例外
* 例外は見つけにくいが、まず必要になったとしても最小限に抑えるべき
* EAVの保守に責任が持てるなら…
* そもそも、非リレーショナルなデータは非リレーショナルなデータベースで管理するべき

## 感想
エンドユーザーカスタマイズによって任意の項目数で任意のデータ型の属性が増える、みたいなケースが無視されているのは意図的なんだろうか。  
リレーショナルデータベースで扱うなということにしているのかも。

半構造化データはあまり解決ではない気がするが、検索の問題は今ならJSONB型(PostgreSQL)などでマシにはなりそう。

# 6: ポリモーフィック関連

## 何をしたか
複数のテーブルのうち、どれか1つに紐付く子テーブルを作る → 親となるテーブルの名前を記録する

## 問題
* 外部キー制約が設定できない

## 解決策
* 交差テーブルを作成する
  * 適切なUNIQUE制約を忘れずに。
  * ただし、どれか1つの親に……という制約はカバーできないので、アプリケーションで担保する
* 共通の親テーブルを作成する (Class Table Inheritance)

## 例外
* ORMを使用していて、このパターンを採用する他にない場合
* 親と子のテーブルの設計時期が大きく異なる場合
  * それぞれ別の製品の場合など (パッケージ製品であったり、複数案件で使い回しているコアであったり)
